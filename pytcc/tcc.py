from ctypes import c_char_p
from functools import wraps
from ._libtcc import (lib, TCC_OUTPUT_MEMORY as MEMORY, TCC_OUTPUT_FILE as FILE,
    TCC_OUTPUT_OBJ as OBJ, TCC_OUTPUT_PREPROCESS as PREPROCESS, TCC_RELOCATE_AUTO as AUTO,
    error_func)
import sys

message = ""

@error_func
def on_error(userdata, tmessage):
        global message
        message = tmessage.decode(sys.getdefaultencoding())

def _bytes(string, encoding=sys.getdefaultencoding()):
    """Always returns a byte string."""
    if isinstance(string, bytes):
        return string
    else:
        return bytes(string, encoding)

class Error(Exception):
    pass

def ok_or_exception(func, *args, **kw):
    """A decorator that raizes an exception if the result of the call is
    nonzero."""
    @wraps(func)
    def f(*args, **kw):
        result = func(*args, **kw)
        if result != 0:
            raise Error("Error in %s: %d: %s" % (func.__name__, result, message))
        return result
    return f

class _DefiningSymbolsDict(dict):
    """A dictionary that defines symbols in the TCC compiler."""
    def __init__(self, state):
        super(_DefiningSymbolsDict, self).__init__()
        self.state = state

    def __setitem__(self, item, value):
        super(_DefiningSymbolsDict, self).__setitem__(item, value)
        lib.tcc_define_symbol(self.state, _bytes(item), _bytes(value))

    def __delitem__(self, item):
        super(_DefiningSymbolsDict, self).__delitem__(item)
        lib.tcc_undefine_symbol(self.state, _bytes(item))

class TCC(object):
    """Represents a TCCState structure.
    The output type parameter, if present, controls if TCC will generate
    executable code in a file or the code will be directly executed in
    memory."""
    def __init__(self, output_type=MEMORY):
        self.state = lib.tcc_new()
        self._library_path = None
        self.output_type = output_type
        self.preprocessor_symbols = _DefiningSymbolsDict(self.state)
        lib.tcc_set_error_func(self.state, None, on_error)

    def __del__(self):
        return lib.tcc_delete(self.state)

    @property
    def library_path(self):
        return self._library_path

    @library_path.setter
    def library_path(self, path):
        self._library_path = path
        return lib.tcc_set_lib_path(self.state, _bytes(path))

    @ok_or_exception
    def add_include_path(self, path):
        """Adds the specified path to the TCC search path list."""
        return lib.tcc_add_include_path(self.state, _bytes(path))

    @ok_or_exception
    def add_sysinclude_path(self, path):
        """Adds the specified path to the TCC system include search path
        list, so that #include <foo.h> if foo.h is in this path will work for
        example."""
        return lib.tcc_add_sysinclude_path(self.state, _bytes(path))

    @ok_or_exception
    def add_file(self, path):
        """Adds the specified file for compilation."""
        return lib.tcc_add_file(self.state, _bytes(path))

    @ok_or_exception
    def compile_string(self, string):
        """Compiles the C source code in the specified string or bytes
        object."""
        return lib.tcc_compile_string(self.state, _bytes(string))

    def compile_file(self, file):
        """Compiles the C source code in the file specified.
        The file parameter can be a file name as string or a file-like
        object for reading."""
        if hasattr(file, "read"):
            return self.compile_string(file.read())
        else:
            with open(file, "r") as f:
                return self.compile_file(f)

    @property
    def output_type(self):
        """Controls if TCC will write the compilled program to a file or
        executed in-memory."""
        return self.output_type

    @output_type.setter
    @ok_or_exception
    def output_type(self, type):
        self._output_type = type
        return lib.tcc_set_output_type(self.state, type)

    @ok_or_exception
    def add_library_path(self, path):
        """Adds the specified path to the TCC library search path
        list."""
        return lib.tcc_add_library_path(self.state, _bytes(path))

    @ok_or_exception
    def add_library(self, library):
        """Links the specified library in the code generated by TCC."""
        return lib.tcc_add_library(self.state, _bytes(library))

    @ok_or_exception
    def add_symbol(self, symbol, value):
        """Adds the specified ctypes function as a symbol to the
        compilled program, so it can be referenced and
        used to callback Python in the C code."""
        return lib.tcc_add_symbol(self.state, _bytes(symbol), value)

    @ok_or_exception
    def output_file(self, path):
        """Writes the compilled program to the filename specified."""
        return lib.tcc_output_file(self.state, _bytes(path))

    @ok_or_exception
    def _run(self, argc, argv):
        """Internal method. Runs the compilled program passing the
        specified argc and argv."""
        return lib.tcc_run(self.state, argc, argv)

    def run(self, argv=None):
        """Runs the compilled program. If argv is specified, it will be
        exposed to the C code as the program's command line."""
        if argv is None:
            argv = []
        c_argc = len(argv)
        if argv:
            c_argv = (c_char_p * c_argc)(*[c_char_p(_bytes(x)) for x in argv])
        else:
            c_argv = None
        return self._run(c_argc, c_argv)

    @ok_or_exception
    def relocate(self, type=AUTO):
        """Exposes the compilled program's symbols for Python to use."""
        return lib.tcc_relocate(self.state, type)

    def get_symbol(self, symbol):
        """Gets the specified symbol from the compilled program
        (normally a function)."""
        return lib.tcc_get_symbol(self.state, _bytes(symbol))
